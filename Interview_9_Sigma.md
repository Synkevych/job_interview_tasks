# Junior Ruby Developer - Sigma

- [Junior Ruby Developer - Sigma](#junior-ruby-developer---sigma)
  - [Ruby basic](#ruby-basic)
    - [Основные принципы ООП](#основные-принципы-ооп)
    - [DRY принципы](#dry-принципы)
    - [REST архитектура](#rest-архитектура)
    - [SOLID принципы](#solid-принципы)
    - [Что такое объект](#что-такое-объект)
    - [Что такое класс](#что-такое-класс)
    - [Класс можно использовать без инициализации](#класс-можно-использовать-без-инициализации)
    - [extand and include](#extand-and-include)
    - [Парадигма MVC](#парадигма-mvc)
    - [Переменные и константы](#переменные-и-константы)
    - [Разница module и class](#разница-module-и-class)
  - [Работа с базами данных](#работа-с-базами-данных)
    - [Нормализация базы данных](#нормализация-базы-данных)
    - [Нормализация таблиц](#нормализация-таблиц)
    - [FOREIGN KEY and PRIMARY KEY](#foreign-key-and-primary-key)
    - [ORM - Object Rational Mapping](#orm---object-rational-mapping)
    - [Разница между реляционными базами и не реляционными](#разница-между-реляционными-базами-и-не-реляционными)
  - [Ruby on Rails](#ruby-on-rails)
    - [Типы переменных и их область видимости](#типы-переменных-и-их-область-видимости)
    - [Виды глобальных классов доступных](#виды-глобальных-классов-доступных)
    - [ActiveRecord](#activerecord)
    - [ActiveModel](#activemodel)
    - [Для чего используются хелперы](#для-чего-используются-хелперы)
    - [Зависимости one to one, one to many, many to many](#зависимости-one-to-one-one-to-many-many-to-many)
    - [Написать функцию изменения предложения](#написать-функцию-изменения-предложения)
    - [Описать процесс создания Rails приложения](#описать-процесс-создания-rails-приложения)
  - [Вопросы по сети](#вопросы-по-сети)
    - [DNS](#dns)
    - [IP](#ip)
    - [TCP](#tcp)
    - [UDP](#udp)
    - [HTTP/HTTPs](#httphttps)
    - [CORS](#cors)

## Ruby basic

### Основные принципы ООП

Объектно ориентированое програмирование - методология программирования основанная на предствлении программы в виде совокупности объектов, каждый из которых являются екземпляром определенного класса.

**Инкапсуляция** - однин объект не может изменять состояние другого, для этого он должен использовать его поведением, или его методами. Пользователь класса или подсистемы должен видеть и использовать только инткрфейс(список декларируемых свойств и методов) и не вникать во внутреннюю реализацию.

**Полиморфизм** классы-потомки могут изменять реализацию метода каласса-предка, сохраняя его сигнатуру(таким образом сохраняя неизмененным интерфейс класса предка). Даеть возможность обрабатывать классы потомков таким образом как будто они принадлежат классу предку.

**Наследование** - возможность породжать один класс от другого с сохранением всех всойств и методов класса-передка(суперкласса) добавляя при необхожимости новые свойства и методы. Призвано отобразить такое свойство реального мира как иерархичность.

Композиция гибче наследования поэтому ее рекомендуется использовать, если это возможно.

### DRY принципы

Don't Repeat Yourself - не повторяйся - его переиспользование через наследование или рефакторинг. Буквально нужно уходть от дублирования кода и по возмлжности использовать абстрацию для общих вещей.

Если есть одинаковый блок кода в более чем двух местах вынесите его в отдельный метод.

### REST архитектура

Архитектурный стиль взаимодействия компонентов распределённого клиент-серверного приложения в сети. Представляет собой согласованых ограничений, учитывемых при проектировании распределенной системы. Упрощает роутинг и построение API, в определенных случаях приводит к увеличению производительности.

### SOLID принципы

SOLID это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании, предложенных Робертом Мартином: 

- Single responsibility — принцип единственной ответственности, не должно быть более одной причины для изменения класса, или класс должен всегда обрабатывать одну функциональность
- Open-closed — принцип открытости / закрытости - классы методы или функции должны быть открыты для расширения (добаления новой функциональности) и закрыты для модификации.
- **Liskov substitution** — принцип подстановки Барбары Лисков - подтипы должны быть заменяемыми для супертипа, методы или фунции работающиие с суперклассом, должны иметь возможность без проблем работать также с его подклассами. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом. Следование принципу LSP заключается в том, что при построении иерархий наследования создаваемые наследники должны корректно реализовывать поведение базового типа. То есть если базовый тип реализует определённое поведение, то это поведение должно быть корректно реализовано и для всех его наследников.
- **Interface segregation** — принцип разделения интерфейса. Клиенты не должны зависеть от методов, которые они не используют. Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
- **Dependency inversion** — принцип инверсии зависимостей. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

### Что такое объект

Сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса (например, после запуска результатов компиляции и связывания исходного кода на выполнение).

Объект в ООП — это сущность, способная сохранять свое состояние (информацию) и обеспечивающая набор операций (поведение) для проверки и изменения этого состояния. Состояние объекта характеризуется текущим значением его атрибутов.

### Что такое класс

- шаблон кода по которому создается какой-то объект

Класс — это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию

### Класс можно использовать без инициализации

- Можно использовать с помощью метода self

### extand and include

Вы делаете **include** модуля чтобы добавить методы экземпляра класса и **extend** - чтобы добавить методы класса. 
**include** — добавляет методы модуля объекту.
**extend** — вызывает include для синглтон-класса объекта.

Объекты в Ruby не хранят свои собственные методы. Вместо этого они создают синглтон-класс, чтобы он хранил их методы.

```ruby
class A
  def self.who_am_i
    puts self
  end
# Метод who_am_i будет прикрепленный к синглтон-классу 
  def speak_up(input)
    puts input.upcase
  end
end

A.singleton_methods # методы в классе ‘A
#=> [:who_am_i]
```

Тоже самое происходит с экземплярами класса. Если у нас есть объект класса A и мы добавляем к нему метод, мы не можем хранить этот метод внутри самого объекта. Запомните — объекты в Ruby не хранят свои собственные методы.

```ruby
a = A.new

def a.not_so_loud(input)
  puts input.downcase
end
#Здесь опять создается синглтон-класс для объекта "a", чтобы он хранил метод not_so_loud.
```

Когда вы делаете include модуля в объект, вы добавляете методы в цепь наследования объекта.

```ruby
class A
  include M
end
```

### Парадигма MVC

Mодель-представление-контроллер — это паттерн проектирования веб-приложений, который включает в себя несколько более мелких шаблонов. При использовании MVC модель данных приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента, благодаря чему модификация одного из них оказывает минимальное воздействие на остальные или не оказывает его вовсе.

Основная цель применения MVC состоит в разделении данных и бизнес-логики от визуализации.Упрощается сопровождение программного кода: внесение изменений во внешний вид, например, не отражаются на бизнес-логике, а изменения бизнес-логики не затрагивают визуализацию.

Использование паттерна MVC также позволяет следовать принципам SOLID в ООП и принципу DRY.

### Переменные и константы

- константы нельзя изменять, при изменении будет ошибка
- константы являются общедоступными, переменные екземпляра класса недоступны
- Константы будут ссылатся на значение в контексте, в котором они используются а не на текущее значение *self*
- переменные могут изменятся во время выполнение программы

```ruby
class Foo
  BAR = 'Parent'

  def self.speak
    puts BAR
  end
end

class FooChild < Foo
  BAR = 'Child'
end

Foo.speak # Parent
FooChild.speak # Parent
```

### Разница module и class

- Нельзя создать екземпляр модуля, модуль набор функций как и класс
- Екземпляр класса можно создать
  
---

## Работа с базами данных

### Нормализация базы данных

отсутсвие нерабочих ссылок на данные
Нормализация данных – это одна из операций преобразования признаков (Feature Transformation), которая выполняется при их генерации (Feature Engineering) на этапе подготовки данных (Data Preparation). 

### Нормализация таблиц

Сводится к устранению недостатков структуры базы данных, приводящих к различным аномалиям и нарушениям целостности данных.

Выды нормализации и какие из них основные(часто используемые)

### PRIMARY and FOREIGN KEY

**Первичный ключ** -  один из потенциальных ключей отношения, выбранный в качестве основного ключа (или ключа по умолчанию). Если первичный ключ состоит из единственного атрибута, его называют простым ключом.

Если первичный ключ состоит из двух и более атрибутов, его называют составным ключом. Так, номер паспорта и серия паспорта не могут быть первичными ключами по отдельности, так как могут оказаться одинаковыми у двух и более людей.

**Внешний ключ** — это столбец или комбинация столбцов, значения которых соответствуют Первичному ключу в другой таблице. Связь между двумя таблицами задается через соответствие Первичного ключа в одной из таблиц внешнему ключу во второй. 

### ORM - Object Rational Mapping

Object Relational Mapping (объектно-реляционное отображение) - это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных. С помощью ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL, и, в итоге, с меньшим суммарным кодом для доступа в базу данных.

### Разница между реляционными базами и не реляционными

Базы данных NoSQL используют разнообразные модели данных для доступа к данным и управления ими. Базы данных таких типов оптимизированы для приложений, которые работают с большим объемом данных, нуждаются в низкой задержке и гибких моделях данных. Все это достигается путем смягчения жестких требований к непротиворечивости данных, характерных для других типов БД.

В реляционной базе данных запись о книге часто разделяется на несколько частей (или «нормализуется») и хранится в отдельных таблицах, отношения между которыми определяются ограничениями первичных и внешних ключей. В этом примере в таблице «Книги» имеются столбцы «ISBN», «Название книги» и «Номер издания», в таблице «Авторы» – столбцы «ИД автора» и «Имя автора», а в таблице «Автор–ISBN» – столбцы «Автор» и «ISBN». Реляционная модель создана таким образом, чтобы обеспечить целостность ссылочных данных между таблицами в базе данных. Данные нормализованы для снижения избыточности и в целом оптимизированы для хранения.  
В базе данных NoSQL запись о книге обычно хранится как документ JSON. Для каждой книги, или элемента, значения «ISBN», «Название книги», «Номер издания», «Имя автора и «ИД автора» хранятся в качестве атрибутов в едином документе. В такой модели данные оптимизированы для интуитивно понятной разработки и горизонтальной масштабируемости.

---

## Ruby on Rails

### Типы переменных и их область видимости

- глобальная переменная объявляется с помощъю знака `$` доступна во всем приложении, желательно избегать их
- переменная екземпляра класса `@` доступна после объявления экземпляра класса в контексте выполнения(объявлена в контроллере доступна в отображении)
- `@@` - переменная класса, доступна в самом классе
- обычная, локальная переменная объявляется без дополнительных симаолов, доступна до ключевого слова `end`

### Виды глобальных классов доступных в Rails

- Active Record - ответственный за представление бизнес-логики и данных
- Active Job - фреймворк для объявления заданий и их запуска на разных бэкендах для очередей
- Active Support - компонент который отвечает за предоставление расширений для языка Ruby, утилит и др.
- Active Cable - интегрирует WebSockets с остальными частями приложения Rails
- Active Storage - облегчает загрузку файлов в облачные хранилища данных
- Action Mailer - позволяет отправлять електронные письма и приложения, используя классы и вьюхи из рассыльщика

### ActiveRecord

Active Record это M в MVC - модель - которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют персистентного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).

При написании приложения с использованием других языков программирования или фреймворков часто требуется писать много конфигурационного кода. В частности, это справедливо для фреймворков ORM. Однако, если следовать соглашениям, принятым Rails, вам придется написать совсем немного конфигураций (а иногда совсем не придется) при создании моделей Active Record. Идея в том, что в большинстве случаев вы настраиваете свои приложения одинаковым образом, и этот способ должен быть способом по умолчанию. Таким образом, явная конфигурация потребуется только тогда, когда вы не следуете соглашениям по какой-то причине

**Внешние ключи** - Эти поля должны именоваться по образцу singularized_table_name_id (т.е., item_id, order_id). Это поля, которые ищет Active Record при создании связей между вашими моделями.
**Первичные ключи** - По умолчанию Active Record **использует числовой столбец с именем id как первичный ключ таблицы** (bigint для PostgreSQL и MySQL, integer для SQLite). Этот столбец будет автоматически создан при использовании миграций Active Record для создания таблиц.

### ActiveModel

Библиотека Active Model содержит различные модули, используемые для разработки классов, которым необходимы некоторые особенности, присутствующие в Active Record. Некоторые из этих модулей описаны ниже.

Модуль ActiveModel::AttributeMethods позволяет добавлять различные суффиксы и префиксы к методам класса. Для использования необходимо определить суффиксы, префиксы, а также к каким методам объекта они будут применяться.

ActiveModel::Validations - добавляет возможность проверять объекты как в Active Record.

### Для чего используются хелперы

Помощник - это метод, который (в основном) используется в ваших представлениях Rails для обмена повторно используемым кодом. Rails поставляется с набором встроенных вспомогательных методов.

Методы помощника (helper)  доступны не столько в контроллере сколько в представлении, т.е. это его методы, и создан он скорее да разгрузки представление от громоздкого кода. Чтобы методы стали доступны в контроллере, нужно объявлять помощник там принудительно. В случае, если вы будете воплощать методы помощника явно в контроллере и в представлении, вы просто сделаете код нечитаемым. А вообще если говорить именно за "Rails way", то более оптимальная схема такая:

- контроллер - обрабатывает данные входного запроса и пропускает нужные параметры;
- модель - в подавляющем большинстве случаев описывает требования к полям таблицы в БД, связи между таблицами (см. belongs_to, has_many/one) и выборки (см. scope) данных из таблиц по условиям. Могут также быть модели без привязки к конкретной таблице, напр. абстрактные модели. В сем случае, свойства оной просто задают некоторую общую основу для моделей наследников.
- представление - предоставляет описание или точнее схему того, что конечным пользователь увидит в результате своего запроса. Представления обычно описываются шаблонами erb, haml, slim и т.д.

Дополнительно, желательно (а на деле часто необходимо) иметь:

- служба (service) - позволяет разгрузить контроллер от бизнес-логики, каждая служба обычно представляет какую-либо операцию над моделями с возможным привлечением иных служб. Службы можно писать руками, а можно использовать бисер services.

- украситель (decorator) - позволяет разгрузить модель, а зачастую и помощники, от избыточной логики представления, например, от часто вызываются в представлении при отображении записи методов, которые обычно преобразуют для вывода какие-либо данные записи. Тут обычно используется бисер draper.

- сериализёр (выпущик, serializer) - позволяет разгрузить контроллер и модель от бизнес-логики, и выборки, которая необходима конечному пользователю и запрашиваемая через api-вызовы (имеется ввиду внешняя сериализация). Обычно используется бисер active_model_serializers.

### Зависимости one to one, one to many, many to many

Many-to-many relationship in real life is like, a physician can have many patients, and a patient can see many different physicians. One way to set up a many-to-many connection with another model is use has_many :through association. In order to do that, we need to create a new join model. We will use Physician, Patient and Appointment as example.

```ruby
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end
 
class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end
 
class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

### Написать функцию изменения предложения

Функция принимает два аргумента, первый строка с словом(или предложением) второй номер буквы котором нужно сделать UpperCase

```ruby
def upper_letter(phrase, num)
  return 'number need to be >= 1' if num < 1
  i = 0
  result = phrase.split('').map do |letter|
    i += 1
    if ( i % num ) == 0
      letter.upcase
    else
      letter
    end
  end
  result.join()
end
p upper_letter("upper_letter", 2)
```

### Описать процесс создания Rails приложения

1. сгенерировать модель и миграцию, выпольнить миграцию
2. сгенирировать контроллер и отображения, заполнить отображения html кодом
3. написать для контроллера нужные функции
4. добавить в routes нужные роуты

---

## Вопросы по сети

### DNS

Domain Name System - компьютерная распределённая система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене (SRV-запись).

Преобразование запросы пользователя в запрос с ip и данными для более понятного серверам запроса

### протокол IP

Протокол сетевого уровня (часть набора протоколов TCP/IP ), отвечающий за передачу и маршрутизацию сообщений между узлами Internet. Определяет правила, по которым данные разбиваются на пакеты, передающиеся между оконечными системами и маршрутизаторами).

### протокол TCP

Надежный протокол транспортного уровня

Transmission Control Protocol (TCP, протокол управления передачей) — один из основных протоколов передачи данных интернета, предназначенный для управления передачей данных.  
Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета, гарантируя тем самым, в отличие от UDP, целостность передаваемых данных и уведомление отправителя о результатах передачи.

Обмен данными, ориентированный на соединения, может использовать надежную связь, для обеспечения которой протокол уровня 4 посылает подтверждения о получении данных и запрашивает повторную передачу, если данные не получены или искажены. Протокол TCP использует именно такую надежную связь. TCP используется в таких прикладных протоколах, как HTTP, FTP, SMTP и Telnet.

Протокол TCP требует, чтобы перед отправкой сообщения было открыто соединение. Серверное приложение должно выполнить так называемое пассивное открытие (passive open), чтобы создать соединение с известным номером порта, и, вместо того чтобы отправлять вызов в сеть, сервер переходит в ожидание поступления входящих запросов. Клиентское приложение должно выполнить активное открытие (active open), отправив серверному приложению синхронизирующий порядковый номер (SYN), идентифицирующий соединение. Клиентское приложение может использовать динамический номер порта в качестве локального порта.

Сервер должен отправить клиенту подтверждение (ACK) вместе с порядковым номером (SYN) сервера. В свою очередь клиент отвечает АСК, и соединение устанавливается.

### протокол UDP

UDP — это быстрый протокол, не гарантирующий доставки. Если требуется поддержание порядка сообщений и надежная доставка, нужно использовать TCP. UDP главным образом предназначен для широковещательной и групповой передачи.

UDP (**User Datagram Protocol** — протокол пользовательских датаграмм) — один из ключевых элементов набора сетевых протоколов для Интернета. С UDP компьютерные приложения могут посылать сообщения (в данном случае называемые датаграммами) другим хостам по IP-сети без необходимости предварительного сообщения для установки специальных каналов передачи или путей данных.
UDP использует простую модель передачи, без неявных «рукопожатий» для обеспечения надёжности, упорядочивания или целостности данных. Таким образом, UDP предоставляет ненадёжный сервис, и датаграммы могут прийти не по порядку, дублироваться или вовсе исчезнуть без следа. UDP подразумевает, что проверка ошибок и исправление либо не нужны, либо должны исполняться в приложении. Чувствительные ко времени приложения часто используют UDP, так как предпочтительнее сбросить пакеты, чем ждать задержавшиеся пакеты, что может оказаться невозможным в системах реального времени.
Природа UDP как протокола без сохранения состояния также полезна для серверов, отвечающих на небольшие запросы от огромного числа клиентов, например DNS и потоковые мультимедийные приложения вроде IPTV, Voice over IP, протоколы туннелирования IP и многие онлайн-игры.

### HTTP/HTTPs

HTTP – символьно-ориентированный клиент-серверный протокол прикладного уровня без сохранения состояния, на основе **TCP**, который, в свою очередь, работает на базе **IP**.

HTTPS (* HTTP Secure – протокол защищенной передачи гипертекстов; использует порт 443 протокола TCP) в сети реализуются защищенные соединения, обеспечивается за счет добавления слоя шифрования/дешифрования между HTTP и TCP. Им является SSL или его усовершенствованная версия – TLS.

Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей которые передаются в следующем порядке:

- Стартовая строка (англ. Starting line) — определяет тип сообщения;
- Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
- Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

### CORS

Cross-Origin Resource Sharing, механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.

Это система, состоящая из отправки HTTP заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.

The same-origin security policy (рус. "правило ограничения домена") по умолчанию запрещает междоменные запросы. CORS предоставляет веб-серверам возможность контролировать междоменные запросы и позволяет производить безопасный обмен данными между разными доменами.
