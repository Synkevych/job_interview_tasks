# Job Interview Tasks – Front/Back -End Developer

Задания которые мне встречались на интервью, позиция Junior Web Developer

Вопросы собраны по компаниям в отдельных файлах:

[Atlas](Interview_1_Atlas.md)  
[Innovecs](Interview_2_Innovecs.md)  
[GlovalLogic ProCamp](Interview_3_GlobalLogic_ProCamp.md)  
[GlovalLogic Junior FD](Interview_4_GlobalLogic_Junior_FD.md)  
[LuxSoft](Interview_5_LuxSoft.md)  
[Genesis](Interview_6_Genesis.md)  
[SoftServe](Interview_7_SoftServe.md)  
[BlackBird](Interview_8_BlackBird.md)  
[Sigma](Interview_9_Sigma.md)  

## Теоретические вопросы

### Чем отличаются симетричное и асиметричное шифрование

Метод **Симетричного шифрування**
передбачає використання одного і того ж ключа що зберігається у секреті для зашифрування та розшифрування даних.  
Основний недолік ключ повинен бути відомий і відправнику і одержувачу

Метод **Асиметричного шифрування**  в його основі лежить поняття односпрямованої функції що має властивості - прості обчислення значення функції y = f ( x ),  існування оберненої функції  x = f-1(y)  
Цей метод передбачає використання двох ключів. Один з них несекретний і може публікуватися разом з іншими відомостями про користувача, інший секретний і відомий тільки одержувачу - для розшифрування.

### Структуры данных

Структуры данных  — это контейнер, информация в котором скомпонована характерным образом. Благодаря такой «компоновке», структура данных будет эффективна в одних операциях и неэффективна — в других. Наша цель — разобраться в структурах данных таким образом, чтобы вы могли выбрать из них наиболее подходящую для решения конкретной стоящей перед вами задачи. В зависимости от конкретного сценария, данные нужно хранить в подходящем формате. У нас в распоряжении — ряд структур данных, обеспечивающих нас такими различными форматами.

Наиболее распостраненные структуры данных:

- Массивы - простейшая и наиболее распространенная структура данных.
- Стеки -  располагаются в памяти в таком порядке: последний сохраненный элемент идет первым действует принцип LIFO.
- Очереди — это линейная структура данных, элементы в которой хранятся в последовательном порядке, действует принцип FIFO (Первым пришел — первым вышел).
- Связные списки - отличается от массива по выделению памяти, внутренней структуре и по тому, как в нем выполняются базовые операции вставки и удаления. При помощи связных списков реализуются файловые системы, хеш-таблицы и списки смежности. Существуют такие типы связных списков: Односвязный список (однонаправленный), Двусвязный список (двунаправленный)
- Деревья - это иерархическая структура данных, состоящая из вершин (узлов) и ребер, которые их соединяют. Деревья подобны графам, однако, ключевое отличие дерева от графа таково: в дереве не бывает циклов.
- Графы - это множество узлов, соединенных друг с другом в виде сети. Узлы также называются вершинами. Пара (x,y) называется ребром, это означает, что вершина x соединена с вершиной y. Ребро может иметь вес/стоимость — показатель, характеризующий, насколько затратен переход от вершины x к вершине y.
- Боры (в сущности, это тоже деревья, но их целесообразно рассмотреть отдельно).
- Хеш-таблицы - то процесс, применяемый для уникальной идентификации объектов и сохранения каждого объекта по заранее вычисленному индексу, именуемому его «ключом».

### Методы сортировки массивов

В JS для этого можна использовать методы **sort, filter, find, findIndex**

- **Пузырьковый** - при первом проходе самое большое число будет справа

```
22 -1 88 -22
-1 22 -22 88
-1 -22 22 88
-22 -1 22 88
```

- **Методом выбора** - находится минимальный елемент массива и ставится слева, следующий рас начинаем поиск с n-1  елемента

```
22 -2 88 -22
-22 22 -2 88
-22 -2 22 88
```

- **Сортировка вставками** – на i-том етапе делается вставка i-го елемента в нужную позицию среди елементов а[1], a[2], ... a[i-1], которые уже отсортированы

```
22 -2 88 -22
-2 22 88 -22
-22 -2 22 88
```

- **Быстрая сортировка**
Швидке сортування полягає в тому, що множина елементів В { k1, k2, …, kn } перетворюється на множину B1, {k1}, B2, де В1 - підмножина В з елементами, не більшими за k1, а В2 - підмножина В з елементами більшими k1. Причому елемент k1 після розбиття множини В буде перебувати на потрібному місці. Далі до множин B1 і B2 знову застосовують впорядкування швидким сортуванням.

### Сколько информации можно записать в 1 байт / 8 бит

8 бит =  1111 1111 = 2^8-1 = 256-1 = ***255*** максимальное число в 10 системе исчисления

Перевод с 2 системы в 10 -  1111 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*1 = 8 + 4 + 2 + 1 = 15

Используя методы в JS:

```js
parseInt(1111,2) // 15

// Обратный перевод

+parseInt(255).toString(2) //1111 1111
+(45).toString(2) //101101
```

### Result Code and Phrase

| Code | Type | Phrase |
| --- | --- | --- |
| 1xxx | Inforamartional | Not Done Yet |
| 2xxx | Success | You win |
| 3xxx | Redirection | You lose but try again |
| 4xxx | Client Error | You lose, your fault |
| 5xxx | Server Error | You lose, my bad |
