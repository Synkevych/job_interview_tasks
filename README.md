# job_interview_tasks

### 1 Работа с ошибками git
1 В ветке v1 обнаружилась ошибка, через это мы не можем вернуть наши изменения из v2 в master, что нужно сделать чтобы исправить проблемы с веткой v1 ? 

(master) - (v1) - (v2)

### 2 Как слить две ветки v2 & v3 если при автоматическом слиянии есть ошибка ? 

(master) - (v1) - (v2)
          \ _ _ _ (v3)
          
### 3 Чем отличаются симетричное и асиметричное шифрование
Метод Симетричного шифрування 
передбачає використання одного і того ж ключа що зберігається у секреті для зашифрування та розшифрування даних 
- основний недолік ключ повинен бути відомий і відправнику і одержувачу 

Метод асиметричного шифрування  в його основі лежить поняття односпрямованої функції що має властивості - прості обчислення значення функції y = f ( x ),  існування оберненої функції  x = f-1(y) 
Цей метод передбачає використання двох ключів. Один з них несекретний і може публікуватися разом з іншими відомостями про користувача, інший секретний і відомий тільки одержувачу - для розшийрування. 

### 4 Методы сортировки массивов
В JS для этого можна использовать методы sort, filter.

Пузырьковый - при первом проходе самое большое число будет слева
22 -1 88 -22
-1 22 -22 88
-1 -22 22 88
-22 -1 22 88

Методом выбора - находится минимальный елемент массива и ставится справа, следующий рас начинаем поиск с n-1  елемента 
22 -2 88 -22
-22 22 -2 88
-22 -2 22 88

Сортировка вставками – на i-том етапе делается вставка i-го елемента в нужную позицию среди елементов а[1], a[2], ... a[i-1], которые уже отсортированы
22 -2 88 -22 
-2 22 88 -22
-22 -2 22 88

Быстрая сортировка
Швидке сортування полягає в тому, що множина елементів В { k1, k2, …, kn } перетворюється на множину B1, {k1}, B2, де В1 - підмножина В з елементами, не більшими за k1, а В2 - підмножина В з елементами більшими k1. Причому елемент k1 після розбиття множини В буде перебувати на потрібному місці. Далі до множин B1 і B2 знову застосовують впорядкування швидким сортуванням.

### 5 Как взять от 7.32 дробную часть?
double.toString().split(".") // ["4", "234"] 
let double = 7.32 
double.toFixed()	// "7"
double.toPrecision(1)	// "7"
Math.round(double)

### 6 Как с помощью чистой функции добавить к state новый массив

let arr = [1,2,3];
let newArr = [4,5];

Способ 1:

const addEndOfMass = (state = {}, action ) => {
  return { Object.asing({}, ...state, newArr)}
  }
  
### 7 Найболее сложное задание? 

Правильно давать имена переменным и функциям. 

### 8 Почему console.log("string".length)  возвращает число ?
str.length — это числовое свойство не функция
Содержимое строки в JavaScript нельзя изменить. 
Имеет методы Методы toLowerCase() и toUpperCase()  str.trim() — убирает пробелы в начале и конце строки.
str.repeat(n)

### 9 Как функция изменит переменные  / Что вернет console.log(obj, num) 

let obj = { }; 
let num;

function changeItem(obj, num){
          obj.name = "Roman";
          num = 10;
}
console.log(obj, num) // {name: "Roman"} undefined

Сдесь сработает замыкание, если функцию не передавть параметром то она сработает так как и ожидалось 

### 10 Как поведет себя функция ?
Более подробно – [https://habr.com/ru/company/ruvds/blog/340194/]

let i = 0;

for (i; i < 10; i++) {
	setTimeout( () => 
	console.log(i), 100)
}
// (10) 10 
чтобы вывести числа от 0 - 9
– – – – – – – – – – – – – – – – – – 
Поведение изменится если использовать let позволяет создавать новую привязку при каждом вызове функции

for (let i = 0; i < 10; i++) {
	setTimeout( () => 
	console.log(i), 100)
}
– – – – – – – – – – – – – – – – – – 
Явно паредать параметр во внутреннюю функцию

for (var i = 0; i < 10; i++) {
	setTimeout(
		function(i) {
			return function() {
				console.log(i);
			};
		}(i),
		100 ); }
– – – – – – – – – – – – – – – – – – 
Похожая задача только с использованием массива 

const arr = [10, 12, 15, 21];
for (const [i, item] of arr.entries()) {
    setTimeout(console.log, 0, `Index: ${i}, element: ${item}`);
}

### 11 Какую роль играют { } [Curly brackets or braces]
funtion foo(){
let i = 10;
let b = {}:
	{ i += 5;
	  b.name = "Bohdan";
	}
	console.log(i, b) 
Только декоративную, никак не влияют на код

### 12 Сколько информации можно записать в 1 байт / 8 бит 

8 бит = 2^8-1 = 255 
Перевод с 2 системы в 10 -  1111 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*1 = 8 + 4 + 2 + 1 = 15 
parseInt(1111,2) 	// 15

Обратный перевод 
+parseInt(15).toString(2)	//1111 
+(45).toString(2)	//101101

### 13 Какие методы есть в Promis

### 14 Каррирование функций 
Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).

### Наследование прототипное, обектное и функциональное 

